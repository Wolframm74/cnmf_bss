#include "local_inc.hpp"

/*0th sum stuff*/
/*cube::fixed<F_static, N_static, L_static> outtensor_0th_real_FNL;
cx_cube::fixed<F_static, N_static, L_static> outtensor_0th_cx_FNL;*/
mat::fixed<K_static, L_static> Z_inmat_real_Ykl;

/*cube::fixed<M_static, N_static, F_static> Intensor_Xhat_low_mnf;
cx_cube::fixed<M_static, N_static, F_static> Intensor_E_conj_mnf;*/

cube::fixed<N_static, L_static, F_static> outtensor_0th_real_NLF;
cx_cube::fixed<N_static, L_static, F_static> outtensor_0th_cx_NLF;

static cx_mat::fixed<N_static, K_static> dummy_mat_cx_NK[NUM_WORKER_THREADS]; 
static mat::fixed<K_static, K_static> dummy_mat_outerprod_KK[NUM_WORKER_THREADS]; 

static mat::fixed<N_static, K_static> dummy_mat_real_NK[NUM_WORKER_THREADS]; 

/*1st sum stuff*/
cube::fixed<L_static, F_static, M_static> outtensor_1st_real_LFM;
cx_cube::fixed<L_static, F_static, M_static> outtensor_1st_cx_LFM;

/*2nd sum stuff*/
cube::fixed<O_static, L_static, M_static> outtensor_2nd_real_OLM;
cx_cube::fixed<O_static, L_static, M_static> outtensor_2nd_cx_OLM;

/*3rd sum stuff*/
mat::fixed<O_static, L_static> outmat_3rd_real_OL_den;
mat::fixed<O_static, L_static> outmat_3rd_real_OL_num;
cx_mat::fixed<O_static, L_static> outmat_3rd_cx_OL;
mat::fixed<O_static, L_static> dummy_mat_cumsum_OL; 

colvec::fixed<O_static> ones_col_Ox1;
mat::fixed<O_static, L_static> kronmat_real_OL;

static void compute_0th_sum(mat* T_fk_p, mat* V_nk_p, cx_cube* expj_Phi_S_nkf_p, int f_index, int thread_iter){

#ifdef DEBUG	
mexPrintf("Z_update: pthread_self(): %d, compute_0th_sum(), f_index=%d, work_actually_computed_ctr=%d, \n", (int)pthread_self(), f_index, work_actually_computed_ctr);	
#endif

/*KxK outer product computation*/	/*fine, I think*/
dummy_mat_outerprod_KK[thread_iter]=trans((*T_fk_p).row(f_index))*((*T_fk_p).row(f_index));

/*outtensor_0th_real_FNL computation*/	/*fine, I think*/
/*outtensor_0th_real_FNL.subcube(0, n_index, 0, F_static-1, n_index, L_static-1)=(*T_fk_p)*dummy_mat_outerprod_KK[thread_iter]*trans(*Y_lk_p);*/
outtensor_0th_real_NLF.slice(f_index)=(*V_nk_p)*dummy_mat_outerprod_KK[thread_iter]*Z_inmat_real_Ykl;

/*Prepping dummy_mat_real_NK*/
dummy_mat_real_NK[thread_iter]=kron(ones_col_Nx1, (*T_fk_p).row(f_index)); 

/*outtensor_0th_cx_FNL computation*/	/*Might be ok, since you're only doing elementwise stuff on expj_Phi_S_fnk_p*/

dummy_mat_cx_NK[thread_iter]=((*expj_Phi_S_nkf_p).slice(f_index))%(*V_nk_p);

/*dummy_mat_cx_NK[thread_iter]=dummy_mat_cx_NK[thread_iter].each_row()%(*T_fk_p).row(f_index);*/
dummy_mat_cx_NK[thread_iter]=(dummy_mat_cx_NK[thread_iter])%(dummy_mat_real_NK[thread_iter]);

/*outtensor_0th_cx_FNL.subcube(0, n_index, 0, F_static-1, n_index, L_static-1)=dummy_mat_cx_NK[thread_iter]*trans(*Y_lk_p);*/
outtensor_0th_cx_NLF.slice(f_index)=dummy_mat_cx_NK[thread_iter]*Z_inmat_real_Ykl;

}

/*static void compute_1st_sum(cx_cube* Xhat_low_fnm_p, cx_cube* E_conj_fnm_p, int m_index, int f_index){*/
static void compute_1st_sum(cube* Xhat_low_fnm_p, cx_cube* E_conj_fnm_p, int m_index, int f_index){	

/*outtensor_1st_real_LFM computation*/

/*Integrate out n. 1xL=1xN*NxL */	/*Xhat_low_fnm_p: represent differently*/	/*If possible, F should be moved to the very far right */
/*outtensor_1st_real_LFM.subcube(f_index, m_index, 0, f_index, m_index, L_static-1)=(*Xhat_low_fnm_p).subcube(f_index, 0, m_index, f_index, N_static-1, m_index)*outtensor_0th_real_FNL.subcube(f_index,0,0,f_index,N_static-1,L_static-1);	*/
/*outtensor_1st_real_LFM.slice(m_index).col(f_index)=trans(Intensor_Xhat_low_mnf.slice(f_index).row(m_index)*outtensor_0th_real_NLF.slice(f_index));*/
#ifdef DEBUG	
mexPrintf("Z_update: pthread_self(): %d, compute_1st_sum(), m_index=%d, f_index=%d, work_actually_computed_ctr=%d, \n", (int)pthread_self(), m_index, f_index, work_actually_computed_ctr);	
#endif

outtensor_1st_real_LFM.slice(m_index).col(f_index)=trans(((*Xhat_low_fnm_p).slice(m_index).row(f_index))*outtensor_0th_real_NLF.slice(f_index));

/*outtensor_1st_cx_LFM computation*/	/*E_conj_fnm_p represent differently*/	/*Likewise, shift F */
/*outtensor_1st_cx_LFM.subcube(f_index, m_index, 0, f_index, m_index, L_static-1)=(*E_conj_fnm_p).subcube(f_index, 0, m_index, f_index, N_static-1, m_index)*outtensor_0th_cx_FNL.subcube(f_index,0,0,f_index,N_static-1,L_static-1);	*/
/*outtensor_1st_cx_LFM.slice(m_index).col(f_index)=strans(Intensor_E_conj_mnf.slice(f_index).row(m_index)*outtensor_0th_cx_NLF.slice(f_index));	*/
outtensor_1st_cx_LFM.slice(m_index).col(f_index)=strans(((*E_conj_fnm_p).slice(m_index).row(f_index))*outtensor_0th_cx_NLF.slice(f_index));	

}

static void compute_2nd_sum(cube* W_fom_p, cx_cube* W_fom_cx_p, int m_index, int l_index){

#ifdef DEBUG	
mexPrintf("Z_update: pthread_self(): %d, compute_2nd_sum(), m_index=%d, l_index=%d \n", (int)pthread_self(), m_index, l_index);	
#endif

/*Integrate out f, put the result in the real output tensor. 1xO=1xF*FxO*/	/*outtensor_1st_real_LFM might be ok as is. W_fom needs to be rep'd differently */
/*outtensor_2nd_real_MOL.subcube(m_index,0,l_index,m_index, O_static-1,l_index)=outtensor_1st_real_LFM.subcube(0,m_index,l_index, F_static-1,m_index,l_index)*(*W_fom_p).subcube(0,0,m_index,F_static-1, O_static-1,m_index);*/
outtensor_2nd_real_OLM.slice(m_index).col(l_index)=trans(outtensor_1st_real_LFM.slice(m_index).row(l_index)*(*W_fom_p).slice(m_index));

/*Integrate out f for the cx output tensor. */	
/*outtensor_2nd_cx_MOL.subcube(m_index,0,l_index,m_index, O_static-1,l_index)=outtensor_1st_cx_LFM.subcube(0,m_index,l_index, F_static-1,m_index,l_index)*(*W_fom_cx_p).subcube(0,0,m_index,F_static-1, O_static-1,m_index);*/
outtensor_2nd_cx_OLM.slice(m_index).col(l_index)=strans(outtensor_1st_cx_LFM.slice(m_index).row(l_index)*(*W_fom_cx_p).slice(m_index));

}

/*With the exception of the W_fom update, the computation of the 3rd sum involves only M components, and therefore no need to set up a work queue for the computations for this*/
static void compute_3rd_sum_last_thread(mat* Z_ol_p){

/*Do the sum for m=0:M_static-1*/
/*outmat_3rd_real_OL_den=outtensor_2nd_real_MOL.subcube(0,0,0,0,O_static-1,L_static-1)+outtensor_2nd_real_MOL.subcube(1,0,0,1,O_static-1,L_static-1);*/
outmat_3rd_real_OL_den=outtensor_2nd_real_OLM.slice(0)+outtensor_2nd_real_OLM.slice(1);	

outmat_3rd_cx_OL=outtensor_2nd_cx_OLM.slice(0)+outtensor_2nd_cx_OLM.slice(1);

outmat_3rd_real_OL_num=outmat_3rd_real_OL_den+real(outmat_3rd_cx_OL);

(*Z_ol_p)=(*Z_ol_p)%(outmat_3rd_real_OL_num/outmat_3rd_real_OL_den);

/*Project Z_ol onto the nonnegative orthant. ie: zero all negative elements*/
(*Z_ol_p).elem(find((*Z_ol_p)<0)).zeros();

/*Ok. I think this is now fully correct. */
dummy_mat_cumsum_OL=cumsum((*Z_ol_p), 1);

kronmat_real_OL=kron(ones_col_Ox1, dummy_mat_cumsum_OL.row(O_static-1) );


/*(*Z_ol_p).each_row()/dummy_mat_cumsum_OL.submat(O_static-1,0,O_static-1,L_static-1);*/

(*Z_ol_p)=(*Z_ol_p)/kronmat_real_OL;


}

static void Z_0th_sum_start(arg_struct_t* argStruct_p, bool* last_element_p, int thread_iter){

/*Local variables*/
/*int l_index;*/
int f_index;
bool last_thread_to_sleep=false;
bool force_exit=false;
/*bool b_exit_cond_local=false; */

bool compute_flag; 
/*bool last_element=false;*/

while(threads_while_condition_0th_sum_flag&&(!(*last_element_p))&&(!force_exit)) {		/*Change b_exit_cond_global to b_exit_cond_global_0th_sum?? */

	if (!(*last_element_p)) {	/*Assuming you make the outer while a function of last_element_p, then you can remove this. Can re-enable it if and when you're investigating bugs/debugging. */

	if ((!last_element_found_global_flag)&&(check_queue_global_flag)){

	/*Semaphore or mutex lock */
	sem_wait(&queue_sem);

	compute_flag=calculate_queue_index(argStruct_p, &f_index, last_element_p); 	/*Check that ourside world is populating queue wrt f=1:F and not n=1:N*/

	/*Semaphore or mutex unlock */
	sem_post(&queue_sem);

	}

	/*if (b_exit_cond_g||last_element*/	
	if (compute_flag){

	compute_0th_sum(argStruct_p->T_fk_p, argStruct_p->V_nk_p, argStruct_p->expj_Phi_S_nkf_p, f_index, thread_iter);

	sem_wait(&work_actually_computed_sem);
	work_actually_computed_ctr++;

	if ((work_actually_computed_ctr==argStruct_p->work_queue_size)&&last_element_sleep_flag){

		/*Wake up the last element thread*/
		/*sem_post(&last_element_sleep_sem);*/
		work_actually_completed_flag=true; 

	}

	sem_post(&work_actually_computed_sem);

	compute_flag=false;

	}
	/*end if*/

	/*Fix: I think this absolutely needs to be dependent on !(*last_element_p). ie: the thread that finds the last element MUSTN'T EVEN ENTER THIS CODE BLOCK
	AND EXPOSE ITSELF TO THE POSSIBILITY OF GOING TO SLEEP.....*/
	if ((!compute_flag)&&(last_element_found_global_flag)&&(work_actually_completed_flag)&&(!(*last_element_p))){

	sem_wait(&threads_asleep_sem);

	threads_asleep_ctr++;

	if (threads_asleep_ctr==NUM_WORKER_THREADS-1){

		sem_wait(&check_queue_global_sem);
		check_queue_global_flag=false;
		sem_post(&check_queue_global_sem);

		last_thread_to_sleep=true;

	}

	sem_post(&threads_asleep_sem);

	if(last_thread_to_sleep&&last_element_sleep_flag){
		sem_post(&last_element_sleep_sem);
	}

	/*sem_wait(&sleep_sem). aka sleep. when sem_post() is called from the outside world three times by the last_element==true thread, the three threads that were asleep/blocked, should awake and continue from this point. */
	sem_wait(&sleep_sem);

	force_exit=true;

	sem_wait(&threads_asleep_sem);

	threads_asleep_ctr--;

	if (threads_asleep_ctr==0){

		sem_wait(&check_queue_global_sem);
		check_queue_global_flag=true;
		sem_post(&check_queue_global_sem);
	}

	sem_post(&threads_asleep_sem);

	}

	}

	/*If there's anything that would be better off being done, resetting, here as opposed to outside this function, by the last_element==true thread, can catch the thread with an if(){} and make it do something. */

} /*end while*/

}

static void Z_1st_sum_start(arg_struct_t* argStruct_p, bool* last_element_p){
/*Local variables*/
/*int l_index;*/
int m_index;
int f_index;

bool last_thread_to_sleep=false;
bool force_exit=false;

/*bool b_exit_cond_local=false; */

bool compute_flag; 
/*bool last_element=false;*/

while(threads_while_condition_1st_sum_flag&&(!(*last_element_p))&&(!force_exit)) {		/*Change b_exit_cond_global to b_exit_cond_global_0th_sum?? */

	if (!(*last_element_p)) {	/*Assuming you make the outer while a function of last_element_p, then you can remove this. Can re-enable it if and when you're investigating bugs/debugging. */

	if ((!last_element_found_global_flag)&&(check_queue_global_flag)){

	/*Semaphore or mutex lock */
	sem_wait(&queue_sem);

	compute_flag=calculate_pair_queue_indices(argStruct_p, &m_index, &f_index, last_element_p); 

	/*Semaphore or mutex unlock */
	sem_post(&queue_sem);

	}

	/*if (b_exit_cond_g||last_element*/	
	if (compute_flag){

/*	compute_1st_sum(argStruct_p->Xhat_low_fnm_p, argStruct_p->E_conj_fnm_p, m_index, f_index);*/
	compute_1st_sum(argStruct_p->Xhat_low_fnm_p, argStruct_p->E_conj_fnm_p, m_index, f_index);	

	sem_wait(&work_actually_computed_sem);
	work_actually_computed_ctr++;

	if ((work_actually_computed_ctr==argStruct_p->work_queue_size)&&last_element_sleep_flag){

		/*Wake up the last element thread*/
		/*sem_post(&last_element_sleep_sem);*/
		work_actually_completed_flag=true; 

	}

	sem_post(&work_actually_computed_sem);

	compute_flag=false;

	}
	/*end if*/

	/*Fix: I think this absolutely needs to be dependent on !(*last_element_p). ie: the thread that finds the last element MUSTN'T EVEN ENTER THIS CODE BLOCK
	AND EXPOSE ITSELF TO THE POSSIBILITY OF GOING TO SLEEP.....*/
	if ((!compute_flag)&&(last_element_found_global_flag)&&(work_actually_completed_flag)&&(!(*last_element_p))){

	sem_wait(&threads_asleep_sem);

	threads_asleep_ctr++;

	if (threads_asleep_ctr==NUM_WORKER_THREADS-1){

		sem_wait(&check_queue_global_sem);
		check_queue_global_flag=false;
		sem_post(&check_queue_global_sem);

		last_thread_to_sleep=true;

	}

	sem_post(&threads_asleep_sem);

	if(last_thread_to_sleep&&last_element_sleep_flag){
		sem_post(&last_element_sleep_sem);
	}

	/*sem_wait(&sleep_sem). aka sleep. when sem_post() is called from the outside world three times by the last_element==true thread, the three threads that were asleep/blocked, should awake and continue from this point. */
	sem_wait(&sleep_sem);

	force_exit=true;

	sem_wait(&threads_asleep_sem);

	threads_asleep_ctr--;

	if (threads_asleep_ctr==0){

		sem_wait(&check_queue_global_sem);
		check_queue_global_flag=true;
		sem_post(&check_queue_global_sem);
	}

	sem_post(&threads_asleep_sem);

	}

	}

	/*If there's anything that would be better off being done, resetting, here as opposed to outside this function, by the last_element==true thread, can catch the thread with an if(){} and make it do something. */

} /*end while*/
	
}

static void Z_2nd_sum_start(arg_struct_t* argStruct_p, bool* last_element_p){
	
/*Local variables*/
/*int l_index;*/
int l_index;	
int m_index;

bool last_thread_to_sleep=false;
bool force_exit=true;

/*bool b_exit_cond_local=false; */

bool compute_flag; 
/*bool last_element=false;*/

while(threads_while_condition_2nd_sum_flag&&(!(*last_element_p))&&(!force_exit)) {		/*Change b_exit_cond_global to b_exit_cond_global_0th_sum?? */

	if (!(*last_element_p)) {	/*Assuming you make the outer while a function of last_element_p, then you can remove this. Can re-enable it if and when you're investigating bugs/debugging. */

	if ((!last_element_found_global_flag)&&(check_queue_global_flag)){

	/*Semaphore or mutex lock */
	sem_wait(&queue_sem);

	/*You need to create a different function to calculate a pair of queue indices. And therefore should also pass in f_index here to be updated by the function. */
	compute_flag=calculate_pair_queue_indices(argStruct_p, &m_index, &l_index, last_element_p); 

	/*Semaphore or mutex unlock. */
	sem_post(&queue_sem);

	}

	/*if (b_exit_cond_g||last_element*/	
	if (compute_flag){

	compute_2nd_sum(argStruct_p->W_fom_p, argStruct_p->W_fom_cx_p, m_index, l_index);

	sem_wait(&work_actually_computed_sem);
	work_actually_computed_ctr++;

	if ((work_actually_computed_ctr==argStruct_p->work_queue_size)&&last_element_sleep_flag){

		/*Wake up the last element thread*/
		/*sem_post(&last_element_sleep_sem);*/
		work_actually_completed_flag=true;

	}

	sem_post(&work_actually_computed_sem);

	compute_flag=false;

	}
	/*end if*/

	/*Fix: I think this absolutely needs to be dependent on !(*last_element_p). ie: the thread that finds the last element MUSTN'T EVEN ENTER THIS CODE BLOCK
	AND EXPOSE ITSELF TO THE POSSIBILITY OF GOING TO SLEEP.....*/
	if ((!compute_flag)&&(last_element_found_global_flag)&&(work_actually_completed_flag)&&(!(*last_element_p))){

	sem_wait(&threads_asleep_sem);

	threads_asleep_ctr++;

	if (threads_asleep_ctr==NUM_WORKER_THREADS-1){

		sem_wait(&check_queue_global_sem);
		check_queue_global_flag=false;
		sem_post(&check_queue_global_sem);

		last_thread_to_sleep=true; 
	}

	sem_post(&threads_asleep_sem);

	if(last_thread_to_sleep&&last_element_sleep_flag){
		sem_post(&last_element_sleep_sem);
	}

	/*sem_wait(&sleep_sem). aka sleep. when sem_post() is called from the outside world three times by the last_element==true thread, the three threads that were asleep/blocked, should awake and continue from this point. */
	sem_wait(&sleep_sem);

	force_exit=true;

	sem_wait(&threads_asleep_sem);

	threads_asleep_ctr--;

	if (threads_asleep_ctr==0){

		sem_wait(&check_queue_global_sem);
		check_queue_global_flag=true;
		sem_post(&check_queue_global_sem);
	}

	sem_post(&threads_asleep_sem);

	}

	}

	/*If there's anything that would be better off being done, resetting, here as opposed to outside this function, by the last_element==true thread, can catch the thread with an if(){} and make it do something. */

} /*end while*/
	
}

void* Z_start(void* arg){


thread_arg_t* threadArg_p;
arg_struct_t* argStruct_p;

bool local_while_condition=false;
bool last_element_flag=false; 
int thread_iter;

/*Cast the void* arg into a arg_struct_t**/
threadArg_p=(thread_arg_t*)arg;
argStruct_p=threadArg_p->argStruct_p; 
thread_iter=threadArg_p->thread_iter; 

Z_0th_sum_start(argStruct_p, &last_element_flag, thread_iter);
	
/*Allow the last thread to get to this point, and charge the last thread with the task of re-populating the queue. */	

if (last_element_flag){

if (work_actually_computed_ctr<(argStruct_p->work_queue_size)){

	/*Sleep until the last thread to sleep gets to a point as close as possible to when it's about to sleep*/
	/*The intent is for the thread to wake you right before it goes to sleep.*/	
	last_element_sleep_flag=true; 

	sem_wait(&last_element_sleep_sem);

	/*Reset last_element_sleep_flag*/
	last_element_sleep_flag=false;	

}

/*Wrap this with a while loop to busy loop until condition is met*/
while(!local_while_condition){

	if (work_actually_completed_flag){

	/*Repopulate queue wrt M, F*/
	populate_queue_wrt_pair_indices(argStruct_p, M_static, F_static);

	local_while_condition=true;

	}

}

local_while_condition=false;

/*I think also reset: last_element_found_global_flag to false */
/*Consider creating a semaphore for this and wrapping it, but for now do without*/
last_element_found_global_flag=false;

/*Set the threads_while_condition_0th_sum_flag to a state that allows the just awoken threads to break their while loops. */
/*Wrap this write operation with a semaphore lock.*/
sem_wait(&threads_while_condition_0th_sum_sem);
threads_while_condition_0th_sum_flag=false;	
sem_post(&threads_while_condition_0th_sum_sem);

/*Wake the other threads by calling sem_post() three times. */
	sem_post(&sleep_sem);
	sem_post(&sleep_sem);
	sem_post(&sleep_sem);

/*Reset*/
work_actually_completed_flag=false;
work_actually_computed_ctr=0;	

} /*endif*/

/*reset last_element_flag to false for all threads*/
last_element_flag=false;

Z_1st_sum_start(argStruct_p, &last_element_flag);

if (last_element_flag){

if (work_actually_computed_ctr<(argStruct_p->work_queue_size)){

	/*Sleep until the last thread to sleep gets to a point as close as possible to when it's about to sleep*/
	/*The intent is for the thread to wake you right before it goes to sleep.*/	
	last_element_sleep_flag=true; 

	sem_wait(&last_element_sleep_sem);

	/*Reset last_element_sleep_flag*/
	last_element_sleep_flag=false;	

}

/*Wrap this with a while loop to busy loop until condition is met*/
while(!local_while_condition){

	if (work_actually_completed_flag){

	/*Repopulate queue wrt M, L */
	populate_queue_wrt_pair_indices(argStruct_p, M_static, L_static);

	local_while_condition=true;

	}

}

local_while_condition=false;

/*Reset this flag*/
last_element_found_global_flag=false;

sem_wait(&threads_while_condition_1st_sum_sem);
threads_while_condition_1st_sum_flag=false;	
sem_post(&threads_while_condition_1st_sum_sem);

/*Wake up the other threads*/
	sem_post(&sleep_sem);
	sem_post(&sleep_sem);
	sem_post(&sleep_sem);

/*Reset*/
work_actually_completed_flag=false;
work_actually_computed_ctr=0;		

}

last_element_flag=false; 

Z_2nd_sum_start(argStruct_p, &last_element_flag);

if (last_element_flag){

if (work_actually_computed_ctr<(argStruct_p->work_queue_size)){

	/*Sleep until the last thread to sleep gets to a point as close as possible to when it's about to sleep*/
	/*The intent is for the thread to wake you right before it goes to sleep.*/	
	last_element_sleep_flag=true; 

	sem_wait(&last_element_sleep_sem);

	/*Reset last_element_sleep_flag*/
	last_element_sleep_flag=false;	

}

/*Here is the chance for the last_element thread to do anything serially while 3 of the other 4 threads are currently asleep*/
compute_3rd_sum_last_thread(argStruct_p->Z_ol_p);

/*Don't repopulate queue */	

/*Reset this flag, although probably unecessary in this case. */
last_element_found_global_flag=false;

/*Set this flag to false so that sleeping threads can exit their while condition upon awaking. */
sem_wait(&threads_while_condition_2nd_sum_sem);
threads_while_condition_2nd_sum_flag=false;	
sem_post(&threads_while_condition_2nd_sum_sem);

/*Wake up the other threads*/
	sem_post(&sleep_sem);
	sem_post(&sleep_sem);
	sem_post(&sleep_sem);

/*Reset*/
work_actually_completed_flag=false;
work_actually_computed_ctr=0;		

}

last_element_flag=false; 

	
}